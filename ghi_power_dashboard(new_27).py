# -*- coding: utf-8 -*-
"""Ghi_Power_Dashboard(new_27).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17B9NXbxeacICd4xIKb9d2UdGzMg7h0Ia
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from datetime import datetime

MODEL_CSV_MAP = {
    "LSTM": "pred_df_with_capacity.csv",
    "LightGBM": "pred_df_with_capacity (1).csv"
}

def load_prediction_data(csv_path):
    df = pd.read_csv(csv_path)
    df["issue_datetime"] = pd.to_datetime(df["issue_datetime"])
    df["delivery_datetime"] = pd.to_datetime(df["delivery_datetime"])
    df = df.sort_values("delivery_datetime")

    return df

def add_block_hours(df):
    df = df.sort_values("delivery_datetime").reset_index(drop=True)

    # Time difference to next block
    df["block_hours"] = (
        df["delivery_datetime"]
        .diff()
        .dt.total_seconds()
        .div(3600)
    )

    # First row fallback (assume 15 min)
    df.loc[df["block_hours"].isna(), "block_hours"] = 0.25

    # Cap abnormal gaps (night gaps, missing blocks)
    df["block_hours"] = df["block_hours"].clip(upper=0.25)

    return df

def compute_power_and_revenue(df):

    PMAX=100

    TARIFF = 3.0

    df["power_actual"] = df["actual_ghi"] / 1000 * PMAX
    df["power_pred"] = df["predicted_ghi"] / 1000 * PMAX

        # üîí Physical clipping
    df["power_actual"] = df["power_actual"].clip(0, PMAX)
    df["power_pred"]   = df["power_pred"].clip(0, PMAX)

    return df

def compute_penalties(df, tariff=3.0):


    df["deviation_mw"] = df["power_actual"] - df["power_pred"]

    df["deviation_pct"] = abs(df["deviation_mw"]) / df["available_capacity"] * 100


    band1_mw = 0.05 * df["available_capacity"]   # 4.5 MW
    band2_mw = 0.05 * df["available_capacity"]   # 4.5 MW

    dev_mw = abs(df["deviation_mw"])

    band1 = np.minimum(dev_mw, band1_mw)
    band2 = np.minimum(np.maximum(dev_mw - band1_mw, 0), band2_mw)
    band3 = np.maximum(dev_mw - band1_mw - band2_mw, 0)

    under = df["deviation_mw"] < 0   # Under-Injection
    over  = df["deviation_mw"] > 0   # Over-Generation

    df["UI_loss"] = 0.0
    df["OG_loss"] = 0.0

    # üîª Under-Injection LOSS
    df.loc[under, "UI_loss"] = (
        1.10 * tariff * band2 +
        1.50 * tariff * band3
    )

    # üî∫ Over-Generation LOSS
    df.loc[over, "OG_loss"] = (
        0.10 * tariff * band2 +     # 10% loss in 5‚Äì10%
        1.00 * tariff * band3       # 100% loss beyond 10%
    )

    return df
def compute_power_mape(df):
    df = df.copy()

    valid = (
        df["power_actual"].notna() &
        df["power_pred"].notna() &
        (df["power_actual"] > 0)
    )

    df.loc[valid, "power_mape_percent"] = (
        abs(df.loc[valid, "power_actual"] - df.loc[valid, "power_pred"])
        / df.loc[valid, "power_actual"]
        * 100
    )

    df.loc[~valid, "power_mape_percent"] = np.nan

    return df

def enforce_15min_grid(df, time_col="delivery_datetime"):
    df = df.sort_values(time_col).set_index(time_col)

    full_index = pd.date_range(
        start=df.index.min(),
        end=df.index.max(),
        freq="15min"
    )

    df = df.reindex(full_index)

    df.index.name = time_col
    df = df.reset_index()

    return df

def mask_bands(df, actual_col, band_cols):
    """
    Show bands only when plant is producing.
    Removes night-time bands and fill triangles.
    """
    mask = (df[actual_col].isna()) | (df[actual_col] <= 0)
    df.loc[mask, band_cols] = np.nan
    return df




# -----------------------------
# STREAMLIT UI
# -----------------------------
st.set_page_config(
    page_title="Solar Power Forecasting Dashboard",
    layout="wide"
)

st.title("‚òÄÔ∏è Solar Power Forecasting & DSM Performance Dashboard")


@st.cache_data
def load_all(csv_path):
    df = load_prediction_data(csv_path)
    df = add_block_hours(df)
    df = compute_power_and_revenue(df)
    df = compute_penalties(df)
    return df


# -----------------------------
# PLANT CONFIGURATION (TOP ROW)
# -----------------------------
st.subheader("üè≠ Plant Configuration")

col_p1, col_p2, col_p3, col_p4 = st.columns([2, 2, 2, 3])


with col_p1:
    country = st.selectbox(
        "Country",
        ["India"],
        index=0
    )

with col_p2:
    state = st.selectbox(
        "State",
        ["Karnataka"],
        index=0
    )

with col_p3:
    plant_type = st.selectbox(
        "Plant Type",
        ["Solar"],
        index=0
    )

with col_p4:
    plant_name = st.selectbox(
        "Plant Name",
        ["Pavagada Solar Plant"],
        index=0
    )


st.divider()
st.subheader("üß† Model Selection")

selected_model = st.selectbox(
    "Forecasting Model",
    ["LSTM", "LightGBM"]
)

selected_csv = MODEL_CSV_MAP[selected_model]
df_master = load_all(selected_csv)

st.subheader("Date & Horizon Selection")

min_date = df_master["delivery_datetime"].min().date()
max_date = df_master["delivery_datetime"].max().date()

# 3 columns in one row
col_start, col_end, col_horizon = st.columns([2, 2, 1])

# -----------------------------
# START DATE
# -----------------------------
start_date = col_start.date_input(
    "Start Date",
    min_value=min_date,
    max_value=max_date,
    value=min_date
)

# -----------------------------
# END DATE
# -----------------------------
end_date = col_end.date_input(
    "End Date",
    min_value=min_date,
    max_value=max_date,
    value=max_date
)

if end_date < start_date:
    st.warning("End date cannot be earlier than start date!")
    st.stop()

# -----------------------------
# HORIZON (SAME LOGIC)
# -----------------------------
available_horizons = sorted(df_master["horizon"].unique())

display_to_actual = {h: h for h in available_horizons}

selected_display_horizon = col_horizon.selectbox(
    "Horizon",
    options=list(display_to_actual.keys())
)

selected_horizon = display_to_actual[selected_display_horizon]

# -----------------------------
# FILTER DATA BY DATE + HORIZON
# ----------------------------

df = df_master.copy()
df["date"] = df["delivery_datetime"].dt.date

# 1Ô∏è‚É£ Filter by UI selections

df = df[
    (df["date"] >= start_date) &
    (df["date"] <= end_date) &
    (df["horizon"] == selected_horizon)
]

# üî• ADD THIS LINE
df = enforce_15min_grid(df)


# 3Ô∏è‚É£ Recompute POWER & REVENUE
df = compute_power_and_revenue(df)

# 4Ô∏è‚É£ Recompute DSM penalties
df = compute_penalties(df)

df["deviation_ghi"] = df["actual_ghi"] - df["predicted_ghi"]

df = compute_power_mape(df)

# 5Ô∏è‚É£ Revenue losses
ui_loss = df["UI_loss"].sum()
oi_loss = df["OG_loss"].sum()

# =============================
# TABS
# =============================
tab_dashboard, tab_download = st.tabs(
    ["üìä Dashboard", "‚¨áÔ∏è Download Data"]
)

with tab_dashboard:
  # -----------------------------
  # GRAPH

  AVAILABLE_CAPACITY = df["available_capacity"]
  PLANT_CAPACITY = 100

  ghi_5  = (0.05 * AVAILABLE_CAPACITY) * 1000 / (PLANT_CAPACITY)
  ghi_10 = (0.10 * AVAILABLE_CAPACITY) * 1000 / (PLANT_CAPACITY)


  # DSM-based GHI bands (derived from DSM deviation equation)
  df["ghi_lower_5"]  = df["actual_ghi"] - ghi_5
  df["ghi_lower_10"] = df["actual_ghi"] - ghi_10

  df["ghi_upper_5"]  = df["actual_ghi"] + ghi_5
  df["ghi_upper_10"] = df["actual_ghi"] + ghi_10

  power_5  = 0.05 * AVAILABLE_CAPACITY   # 4.5 MW
  power_10 = 0.10 * AVAILABLE_CAPACITY   # 9.0 MW

  df["power_lower_5"]  = df["power_actual"] - power_5
  df["power_lower_10"] = df["power_actual"] - power_10
  df["power_upper_5"]  = df["power_actual"] + power_5
  df["power_upper_10"] = df["power_actual"] + power_10


  # üîí PREVENT TRIANGLES (MASK MISSING DATA)
  df = mask_bands(
      df,
      actual_col="power_actual",
      band_cols=[
          "power_upper_10", "power_lower_10",
          "power_upper_5",  "power_lower_5"
      ]
  )

  df = mask_bands(
      df,
      actual_col="actual_ghi",
      band_cols=[
          "ghi_upper_10", "ghi_lower_10",
          "ghi_upper_5",  "ghi_lower_5"
      ]
  )



  st.subheader("üìä Power & Irradiance Overview")

  left_graph, right_graph = st.columns(2)

  # -----------------------------
  # GHI GRAPH (LEFT)
  # -----------------------------
  with left_graph:
      with st.container(border=True):
          fig1 = go.Figure()

          # ¬±5%
          fig1.add_trace(go.Scatter(
              x=df["delivery_datetime"],
              y=df["ghi_upper_5"],
              name="+5% Band",
              line=dict(color="rgba(0,70,140,0.9)", dash="dash", width=2),
          ))

          fig1.add_trace(go.Scatter(
              x=df["delivery_datetime"],
              y=df["ghi_lower_5"],
              name="-5% Band",
              line=dict(color="rgba(0,70,140,0.9)", dash="dash", width=2),
          ))

          fig1.add_trace(go.Scatter(
              x=df["delivery_datetime"],
              y=df["actual_ghi"],
              name="Actual GHI",
              line=dict(width=2.5, color="#2ca02c"),
              connectgaps=False
          ))

          fig1.add_trace(go.Scatter(
              x=df["delivery_datetime"],
              y=df["predicted_ghi"],
              name="Forecast GHI",
              line=dict(width=2.5, dash="dash", color="#d62728"),
              connectgaps=False
          ))

          fig1.update_layout(
              title="Global Horizontal Irradiance (W/m¬≤)",
              yaxis_title="GHI (W/m¬≤)",
              yaxis=dict(
                  title=dict(font=dict(size=16, family="Arial", color="black",weight="bold")),
                  tickfont=dict(size=14, family="Arial", color="black",weight="bold")
              ),
              legend=dict(orientation="h", y=1.1),
              margin=dict(l=20, r=20, t=60, b=40),
              height=380,
              xaxis=dict(
                  tickformat="%b %d %H:%M",   # Month + Day + Hour:Minute, NO weekday, NO year
                  ticklabelmode="period",
                  tickfont=dict(
                      size=12,         # font size
                      family="Arial",  # font family
                      color="black",   # label color
                      # üîπ bold text
                      weight="bold"    # This alone doesn't always work; use font-family that supports bold or wrap in HTML if needed
                  ),
                  rangebreaks=[
                      dict(bounds=[18.5, 6.0], pattern="hour")
                  ])
              )


          st.plotly_chart(fig1, use_container_width=True)


  # -----------------------------
  # POWER GRAPH (RIGHT)
  # -----------------------------
  with right_graph:
      with st.container(border=True):
          fig2 = go.Figure()

          # ¬±10%
          fig2.add_trace(go.Scatter(
              x=df["delivery_datetime"],
              y=df["power_upper_5"],
              name="+5% Band",
              line=dict(color="rgba(0,70,140,0.9)", dash="dash", width=2),
          ))

          fig2.add_trace(go.Scatter(
              x=df["delivery_datetime"],
              y=df["power_lower_5"],
              name="-5% Band",
              line=dict(color="rgba(0,70,140,0.9)", dash="dash", width=2),
          ))

          fig2.add_trace(go.Scatter(
              x=df["delivery_datetime"], y=df["power_actual"],
              name="Actual Power",
              line=dict(width=2.5, color="#2ca02c"),
              connectgaps=False
          ))
          fig2.add_trace(go.Scatter(
              x=df["delivery_datetime"], y=df["power_pred"],
              name="Forecast Power",
              line=dict(width=2.5, dash="dash", color="#d62728"),
              connectgaps=False
          ))


          fig2.update_layout(
              title="Power Comparison (MW)",
              yaxis_title="Power (MW)",
              yaxis=dict(
                  title=dict(font=dict(size=16, family="Arial", color="black",weight="bold")),
                  tickfont=dict(size=14, family="Arial", color="black",weight="bold")
              ),
              legend=dict(orientation="h", y=1.1),
              margin=dict(l=20, r=20, t=60, b=40),
              height=380,
              xaxis=dict(
                  tickformat="%b %d %H:%M",   # Month + Day + Hour:Minute, NO weekday, NO year
                  ticklabelmode="period",
                  tickfont=dict(
                      size=12,         # font size
                      family="Arial",  # font family
                      color="black",   # label color
                      # üîπ bold text
                      weight="bold"    # This alone doesn't always work; use font-family that supports bold or wrap in HTML if needed
                  ),
                  rangebreaks=[
                      dict(bounds=[18.5, 6.0], pattern="hour")
                  ])
              )



          st.plotly_chart(fig2, use_container_width=True)




  # -----------------------------
  # KPIs
  # -----------------------------
  st.subheader("üìå Key Performance Indicators")

  # Bigger + bold text
  st.markdown(
      """
      <style>
      /* Entire metric card */
      div[data-testid="stMetric"] {
          padding-top: 8px;
      }

      /* Metric LABEL (Under-gen Blocks, UI Revenue Loss, etc.) */
      div[data-testid="stMetric"] > label,
      div[data-testid="stMetric"] > div > label,
      div[data-testid="stMetric"] p {
          color: #d62728 !important;   /* RED */
          font-weight: 900 !important;
          font-size: 1.25rem !important;
      }

      /* Metric VALUE (numbers) */
      div[data-testid="stMetric"] div[data-testid="stMetricValue"] {
          color: #1f4ed8 !important;   /* BLUE */
          font-weight: 900 !important;
          font-size: 1.8rem !important;
      }
      </style>
      """,
      unsafe_allow_html=True
  )


  col1, col2, col3, col4 = st.columns(4)

  # ‚úÖ VALID BLOCKS ONLY (exclude NaNs added by enforce_15min_grid)
  valid_blocks = df["deviation_mw"].notna()

  under_pct = (df.loc[valid_blocks, "deviation_mw"] < 0).mean() * 100
  over_pct  = (df.loc[valid_blocks, "deviation_mw"] > 0).mean() * 100

  with col1:
      with st.container(border=True):
          st.metric("UI Blocks", "")
          st.markdown(
              f"<div style='font-size:1.8rem; font-weight:900; color:#1f4ed8;'>"
              f"{under_pct:.1f}%</div>",
              unsafe_allow_html=True
          )

  with col2:
      with st.container(border=True):
          st.metric("OI Blocks", "")
          st.markdown(
              f"<div style='font-size:1.8rem; font-weight:900; color:#1f4ed8;'>"
              f"{over_pct:.1f}%</div>",
              unsafe_allow_html=True
          )



  with col3:
      with st.container(border=True):
          st.metric("UI Revenue Loss", "")
          st.markdown(
              f"<div style='font-size:1.8rem; font-weight:900; color:#1f4ed8;'>"
              f"‚Çπ{abs(ui_loss):,.2f}</div>",
              unsafe_allow_html=True
          )

  with col4:
      with st.container(border=True):
          st.metric("OI Revenue Loss", "")
          st.markdown(
              f"<div style='font-size:1.8rem; font-weight:900; color:#1f4ed8;'>"
              f"‚Çπ{oi_loss:,.2f}</div>",
              unsafe_allow_html=True
          )

  # -----------------------------
  # DSM SLAB DISTRIBUTION + PERFORMANCE SUMMARY
  # -----------------------------

  # Assign explicit DSM bins (Under/Over + slab)
  def assign_dsm_bin(row):
      pct = row["deviation_pct"]
      mw  = row["deviation_mw"]

      if mw < 0:  # Under-generation
          if pct > 10:
              return "Under >10%"
          elif pct > 5:
              return "Under 5‚Äì10%"
          else:
              return "Under 0‚Äì5%"
      else:       # Over-generation
          if pct > 10:
              return "Over >10%"
          elif pct > 5:
              return "Over 5‚Äì10%"
          else:
              return "Over 0‚Äì5%"

  df["dsm_bin"] = df.apply(assign_dsm_bin, axis=1)

  # Exact order required
  bin_order = [
      "Under >10%",
      "Under 5‚Äì10%",
      "Under 0‚Äì5%",
      "Over 0‚Äì5%",
      "Over 5‚Äì10%",
      "Over >10%"
  ]

  bin_counts = (
      df["dsm_bin"]
      .value_counts()
      .reindex(bin_order, fill_value=0)
  )

  # Layout: Graph on left, Summary on right
  left_col, right_col = st.columns([3, 1])

  # -----------------------------
  # LEFT: DSM SLAB GRAPH
  # -----------------------------
  # -----------------------------
  # LEFT: DSM SLAB GRAPH
  # -----------------------------
  with left_col:

      # ‚¨áÔ∏è Move the plot slightly down
      st.markdown("<br><br>", unsafe_allow_html=True)

      # üì¶ Box container
      with st.container(border=True):

          fig3 = go.Figure()

          fig3.add_bar(
              x=bin_counts.index,
              y=bin_counts.values,
              marker_color=[
                  "#cb181d",  # Under >10%
                  "#fb6a4a",  # Under 5‚Äì10%
                  "#fcbba1",  # Under 0‚Äì5%
                  "#c7e9c0",  # Over 0‚Äì5%
                  "#74c476",  # Over 5‚Äì10%
                  "#238b45"   # Over >10%
              ]
          )

          fig3.update_layout(
              title=dict(
                  text="Deviation Distribution (DSM Slabs)",
                  font=dict(size=24, family="Arial Black")
              ),
              xaxis_title="DSM Slab",
              yaxis_title="Number of Blocks",
              xaxis=dict(
                  title=dict(font=dict(size=16, family="Arial", color="black",weight="bold")),
                  tickfont=dict(size=14, family="Arial", color="black",weight="bold")
              ),
              yaxis=dict(
                  title=dict(font=dict(size=16, family="Arial", color="black",weight="bold")),
                  tickfont=dict(size=14, family="Arial", color="black",weight="bold")
              ),
              showlegend=False,
              margin=dict(l=20, r=20, t=60, b=30),
              height=420
          )


          st.plotly_chart(fig3, use_container_width=True)

  # -----------------------------
  # RIGHT: PERFORMANCE SUMMARY
  # -----------------------------
  valid_mape = df["power_mape_percent"].dropna()

  with right_col:
      st.subheader("Performance Summary")

      with st.container(border=True):
          st.metric("Average Power MAPE", "")
          st.markdown(
              f"<div style='font-size:1.8rem; font-weight:900; color:#1f4ed8;'>"
              f"{valid_mape.mean():.2f}%</div>",
              unsafe_allow_html=True
          )


# =============================
# DOWNLOAD DATA TAB
# =============================
with tab_download:

    st.subheader("‚¨áÔ∏è Download Filtered Data")

    export_df = df[[
        "delivery_datetime",
        "horizon",
        "actual_ghi",
        "predicted_ghi",
        "deviation_ghi",
        "power_actual",
        "power_pred",
        "deviation_mw",
        "power_mape_percent"
    ]].copy()

    # Rename columns to business-friendly names
    export_df = export_df.rename(columns={
        "deviation_mw": "deviation_power"
    })

    # ‚ûï Add selected model name
    export_df.insert(0, "Model", selected_model)

    # Remove artificial rows from 15-min grid
    export_df = export_df[export_df["deviation_power"].notna()]
    export_df = export_df.sort_values("delivery_datetime")

    file_format = st.radio(
        "Select file format",
        ["CSV", "Excel", "JSON"],
        horizontal=True
    )

    if file_format == "CSV":
        st.download_button(
            "‚¨áÔ∏è Download CSV",
            export_df.to_csv(index=False),
            "solar_dashboard_data.csv",
            "text/csv"
        )

    elif file_format == "Excel":
        import io
        buffer = io.BytesIO()

        with pd.ExcelWriter(buffer, engine="xlsxwriter") as writer:
            export_df.to_excel(writer, index=False, sheet_name="Data")

        buffer.seek(0)

        st.download_button(
            "‚¨áÔ∏è Download Excel",
            buffer,
            "solar_dashboard_data.xlsx",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )

    else:
        st.download_button(
            "‚¨áÔ∏è Download JSON",
            export_df.to_json(orient="records", date_format="iso"),
            "solar_dashboard_data.json",
            "application/json"
        )

